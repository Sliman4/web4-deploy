#!/usr/bin/env node

const { Web3Storage } = require('web3.storage')

const CID = require('cids');
const { connect, keyStores, Account, KeyPair, transactions } = require('near-api-js');

const path = require('path');
const fs = require('fs');
const timeoutSignal = require("timeout-signal");
const fetch = require('node-fetch');

const { CarReader } = require('@ipld/car');
const { packToFs } = require('ipfs-car/pack/fs');

const NEARFS_GATEWAY_URL = process.env.NEARFS_GATEWAY_URL || 'https://ipfs.web4.near.page';

const meow = require('meow');

const cli = meow(`
    Usage:

        web4-deploy <src-directory> <destination-account.near>

    Options:

        --deployContract [contract-name]   Deploy contract to the account.
            If contract name is not provided, default contract gonna be deployed: https://github.com/vgrichina/web4-min-contract

        --nearfs                           Deploy to NEARFS instead of IPFS.
            See more details on https://github.com/vgrichina/nearfs
`, {
    flags: {
        deployContract: {
            type: 'string',
        },
        nearfs: {
            type: 'boolean',
        }
    },
    allowUnknownFlags: false
});

deploy(cli);

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function deploy(cli) {
    const WEB3_TOKEN = process.env.WEB3_TOKEN;
    const ESTUARY_TOKEN = process.env.ESTUARY_TOKEN;
    if (!WEB3_TOKEN && !ESTUARY_TOKEN && !cli.flags.nearfs) {
        console.error(`
You need to set either WEB3_TOKEN or ESTUARY_TOKEN environment variable to allow IPFS pinning.

WEB3_TOKEN environment variable needs to be set to your web3.storage API token.
See https://web3.storage/docs/how-tos/generate-api-token/ for more information.

ESTUARY_TOKEN environment variable needs to be set to your Estuary API token.
See https://docs.estuary.tech/tutorial-get-an-api-key for more information.

Or use --nearfs flag to deploy to NEARFS instead of IPFS.

`);
        process.exit(1);
    }
    const [ dir, accountId ] = cli.input;

    const NEAR_SIGNER_ACCOUNT = process.env.NEAR_SIGNER_ACCOUNT || accountId;
    const NEAR_SIGNER_KEY = process.env.NEAR_SIGNER_KEY;

    async function connectNEAR() {
        const config = require('../src/config')(process.env.NEAR_ENV || process.env.NODE_ENV);
        const keyStore = NEAR_SIGNER_KEY ? new keyStores.InMemoryKeyStore() : new keyStores.UnencryptedFileSystemKeyStore(`${process.env.HOME}/.near-credentials`);
        if (NEAR_SIGNER_KEY) {
            keyStore.setKey(config.networkId, NEAR_SIGNER_ACCOUNT, KeyPair.fromString(NEAR_SIGNER_KEY));
        }
        const near = await connect({
            ...config,
            keyStore
        })
        const account = new Account(near.connection, NEAR_SIGNER_ACCOUNT);
        return { config, keyStore, near, account };
    }

    const NEARFS_GATEWAY_TIMEOUT = parseInt(process.env.NEARFS_GATEWAY_TIMEOUT || '2500');
    const NEARFS_GATEWAY_RETRY_COUNT = parseInt(process.env.NEARFS_GATEWAY_RETRY_COUNT || '3');
    async function deployNEARFS(carBuffer) {
        const { account } = await connectNEAR();

        console.log('Uploading CAR file to NEAR File System...');

        async function isAlreadyUploaded(cid) {
            const cid32 = cidToString(cid);
            const urlToCheck = `${NEARFS_GATEWAY_URL}/ipfs/${cid32}/`;
            for (let i = 0; i < NEARFS_GATEWAY_RETRY_COUNT; i++) {
                try {
                    const res = await fetch(urlToCheck, { method: 'HEAD', signal: timeoutSignal(NEARFS_GATEWAY_TIMEOUT) });
                    if (res.status === 200) {
                        console.log('Block', cid32, 'already exists on chain, skipping');
                        return true;
                    }

                    if (res.status !== 404) {
                        throw new Error(`Unexpected status code ${res.status} for ${urlToCheck}`);
                    }
                } catch (e) {
                    // Handle AbortError
                    if (e.name === 'AbortError') {
                        console.log('Timeout while checking', urlToCheck);
                        continue;
                    }
                    throw e;
                }
            }

            return false;
        }

        const { readCAR, readBlock, cidToString } = require('fast-ipfs');
        const blocks = readCAR(carBuffer).slice(1).map(b => readBlock(b.data));
        let currentBatch = [];
        const batches = [currentBatch];
        const MAX_BATCH_ACTIONS = 7;
        const MAX_BATCH_BYTES = 256 * 1024;
        const TRHOTTLE_MS = 25;
        const blocksAndStatus = (await Promise.all(blocks.map(async ({ data, cid }, i) => ({ data, cid, uploaded: (await sleep(i * TRHOTTLE_MS), await isAlreadyUploaded(cid)) }))));
        blocksAndStatus.filter(({ uploaded }) => uploaded).map(({ cid }) => cidToString(cid)).forEach(cid => console.log(cid));
        const newBlocks = blocksAndStatus.filter(({ uploaded }) => !uploaded);
        for (let { data } of newBlocks) {
            if (currentBatch.length >= MAX_BATCH_ACTIONS || currentBatch.reduce((a, b) => a + b.length, 0) >= MAX_BATCH_BYTES) {
                currentBatch = [];
                batches.push(currentBatch);
            }

            currentBatch.push(data);
        }

        let totalBlocks = batches.reduce((a, b) => a + b.length, 0);
        let currentBlocks = 0;
        for (let batch of batches) {
            try {
                await account.signAndSendTransaction({
                    receiverId: NEAR_SIGNER_ACCOUNT,
                    actions: batch.map(data => transactions.functionCall('fs_store', data, 0, 0))
                });
            } catch (e) {
                if (e.message.includes('Cannot find contract code for account') || e.message.includes('Contract method is not found')) {
                    // Expected error
                    continue;
                }

                throw e;
            }
            console.log(`Uploaded ${currentBlocks} / ${totalBlocks} blocks to NEARFS`);
        }
    }

    console.log('Packaging files into a CAR file...');
    const tmpDir = fs.mkdtempSync('web4-deploy-');
    const carFile = `${tmpDir}/deploy.car`;
    // NOTE: packToBlob seems to pack raw input string instead of files? TODO: Figure out how to avoid tmp file
    const { root } = await packToFs({ input: dir, output: carFile, wrapWithDirectory: false });
    const carBuffer = Buffer.from(fs.readFileSync(carFile));
    fs.rmSync(tmpDir, { recursive: true });

    const carReader = await CarReader.fromBytes(carBuffer);

    if (ESTUARY_TOKEN) {
        console.log('Uploading CAR file to Estuary...');
        const addCar = await fetch('https://upload.estuary.tech/content/add-car', {
            headers: {
                'Authorization': `Bearer ${ESTUARY_TOKEN}`,
            },
            method: 'POST',
            body: carBuffer
        });

        if (!addCar.ok) {
            throw new Error('Failed to upload CAR file to Estuary');
        }
    }

    if (WEB3_TOKEN) {
        console.log('Uploading CAR file to web3.storage...')
        const storage = new Web3Storage({ token: WEB3_TOKEN })
        await storage.putCar(carReader);
    }

    if (cli.flags.nearfs) {
        await deployNEARFS(carBuffer);
    }

    const rootCID32 = new CID(root.toString()).toV1().toString('base32');
    const cids = [];
    for await (const cid of carReader.cids()) {
        cids.push(new CID(cid.toString()).toV1().toString('base32'));
    }

    if (ESTUARY_TOKEN || WEB3_TOKEN) {
        await checkIPFSGateways(cids);
    }

    const { config, account } = await connectNEAR();

    if (cli.flags.deployContract != undefined) {
        await deployContract(account, cli.flags.deployContract);
    }

    const url = `ipfs://${rootCID32}`;
    console.log('\nUpdating static url', url);

    try {
        const { transaction: { hash } } = await account.functionCall(accountId, 'web4_setStaticUrl', { url });
        console.log('Updated in transaction:', `${config.explorerUrl}/transactions/${hash}`);
    } catch (e) {
        if (e.message.includes('Cannot find contract code for account')) {
            console.log(`
Account ${account.accountId} doesn't have a contract deployed yet.
Please deploy contract first using --deploy-contract option.

Example:

    web4-deploy website/source/dir ${account.accountId} --deploy-contract ./out/main.wasm


You can use default contract as well:

    web4-deploy website/source/dir ${account.accountId} --deploy-contract

This going to deploy mimimal contract which just sets static url to the one provided.
See https://github.com/vgrichina/web4-min-contract.

            `);
            process.exit(1);
        }

        throw e;
    }

    async function checkIPFSGateways(cids) {
        const IPFS_GATEWAY_LIST = (process.env.IPFS_GATEWAY_LIST || 'cloudflare-ipfs.com').split(',');
        const IPFS_CHECK_DELAY = 15000;

        await Promise.all(IPFS_GATEWAY_LIST.map(async (gateway) => {
            const remainingCids = [...cids];
            do {
                console.log(gateway, 'remaining files', remainingCids.length);
                const cid32 = remainingCids.shift();
                const urlToCheck = `https://${gateway}/ipfs/${cid32}/`;
                console.log(`Checking ${urlToCheck}...`);
                try {
                    const res = await fetch(urlToCheck, { signal: timeoutSignal(5000) });
                    console.log(res.status, urlToCheck);
                    if (res.status == 429) {
                        console.log('Too many requests, sleeping...');
                        await sleep(IPFS_CHECK_DELAY);
                    }
                    if (!res.ok) {
                        console.log('Error while fetching', urlToCheck, res.status, res.statusText);
                        remainingCids.push(cid32);
                    }
                } catch (e) {
                    if (e.name === 'AbortError') {
                        remainingCids.splice(0, 0, cid32);
                        console.log(`${urlToCheck} timeout, retrying after extra delay...`);
                        await sleep(IPFS_CHECK_DELAY);
                    } else {
                        remainingCids.push(cid32);
                        console.error(urlToCheck, e);
                    }
                }
            } while (remainingCids.length > 0);
        }));
    }
}

async function deployContract(account, contractPath) {
    console.log('Deploying contract...');
    // NOTE: This contract is taken from https://github.com/vgrichina/web4-min-contract
    contractPath = contractPath || path.resolve(__dirname, '../data/web4-min.wasm');
    const contract = fs.readFileSync(contractPath);

    await account.deployContract(contract);
}
