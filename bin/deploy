#!/usr/bin/env node

const { Web3Storage } = require('web3.storage')

const CID = require('cids');
const { connect, keyStores, Account, KeyPair } = require('near-api-js');

const fs = require('fs');
const timeoutSignal = require("timeout-signal");
const fetch = require('node-fetch');

const { CarReader } = require('@ipld/car');
const { packToFs } = require('ipfs-car/pack/fs');

(async () => {
    const args = process.argv.slice(2);
    if (args.length != 2) {
        console.error(`Usage:
    ipfs-deploy <src-directory> <destination-account.near>

`);

        process.exit(1);
    }

    const WEB3_TOKEN = process.env.WEB3_TOKEN;
    const ESTUARY_TOKEN = process.env.ESTUARY_TOKEN;
    if (!WEB3_TOKEN && !ESTUARY_TOKEN) {
        console.error(`
You need to set either WEB3_TOKEN or ESTUARY_TOKEN environment variable to allow IPFS pinning.

WEB3_TOKEN environment variable needs to be set to your web3.storage API token.
See https://web3.storage/docs/how-tos/generate-api-token/ for more information.

ESTUARY_TOKEN environment variable needs to be set to your Estuary API token.
See https://docs.estuary.tech/tutorial-get-an-api-key for more information.

`);
        process.exit(1);
    }
    const [ dir, accountId ] = args;

    const NEAR_SIGNER_ACCOUNT = process.env.NEAR_SIGNER_ACCOUNT || accountId;
    const NEAR_SIGNER_KEY = process.env.NEAR_SIGNER_KEY;

    console.log('Packaging files into a CAR file...');
    const tmpDir = fs.mkdtempSync('web4-deploy-');
    const carFile = `${tmpDir}/deploy.car`;
    // NOTE: packToBlob seems to pack raw input string instead of files? TODO: Figure out how to avoid tmp file
    const { root } = await packToFs({ input: dir, output: carFile, wrapWithDirectory: false });
    const carBuffer = Buffer.from(fs.readFileSync(carFile));
    fs.rmSync(tmpDir, { recursive: true });

    const carReader = await CarReader.fromBytes(carBuffer);

    if (ESTUARY_TOKEN) {
        console.log('Uploading CAR file to Estuary...');
        const addCar = await fetch('https://upload.estuary.tech/content/add-car', {
            headers: {
                'Authorization': `Bearer ${ESTUARY_TOKEN}`,
            },
            method: 'POST',
            body: carBuffer
        });

        if (!addCar.ok) {
            throw new Error('Failed to upload CAR file to Estuary');
        }
    }

    if (WEB3_TOKEN) {
        console.log('Uploading CAR file to web3.storage...')
        const storage = new Web3Storage({ token: WEB3_TOKEN })
        await storage.putCar(carReader);
    }


    const IPFS_GATEWAY_LIST = (process.env.IPFS_GATEWAY_LIST || 'ipfs.near.social,cloudflare-ipfs.com').split(',');
    const IPFS_CHECK_DELAY = 15000;
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const rootCID32 = new CID(root.toString()).toV1().toString('base32');
    const cids = [];
    for await (const cid of carReader.cids()) {
        cids.push(new CID(cid.toString()).toV1().toString('base32'));
    }

    await Promise.all(IPFS_GATEWAY_LIST.map(async gateway => {
        const remainingCids = [...cids];
        do {
            console.log(gateway, 'remainingCids', remainingCids.length);
            const cid32 = remainingCids.shift();
            const urlToCheck = `https://${gateway}/ipfs/${cid32}/`;
            console.log(`Checking ${urlToCheck}...`);
            try {
                const res = await fetch(urlToCheck, { signal: timeoutSignal(5000) });
                console.log(res.status, urlToCheck);
                if (res.status == 429) {
                    console.log('Too many requests, sleeping...');
                    await sleep(IPFS_CHECK_DELAY);
                }
                if (!res.ok) {
                    console.log('Error while fetching', urlToCheck, res.status, res.statusText);
                    remainingCids.push(remainingCids);
                }
            } catch (e) {
                remainingCids.push(cid32);

                if (e.name === 'AbortError') {
                    console.log(`${urlToCheck} timeout, retrying different CID...`)
                } else {
                    console.error(urlToCheck, e);
                }
            }
        } while (remainingCids.length > 0);
    }));


    const url = `ipfs://${rootCID32}`;
    console.log('\nUpdating static url', url);

    const config = require('../src/config')(process.env.NODE_ENV);
    const keyStore = NEAR_SIGNER_KEY ? new keyStores.InMemoryKeyStore() : new keyStores.UnencryptedFileSystemKeyStore(`${process.env.HOME}/.near-credentials`);
    if (NEAR_SIGNER_KEY) {
        keyStore.setKey(config.networkId, NEAR_SIGNER_ACCOUNT, KeyPair.fromString(NEAR_SIGNER_KEY));
    }
    const near = await connect({
        ...config,
        keyStore
    })
    let account = new Account(near.connection, NEAR_SIGNER_ACCOUNT);
    const { transaction: { hash } } = await account.functionCall(accountId, 'web4_setStaticUrl', { url });
    console.log('Updated in transaction:', `${config.explorerUrl}/transactions/${hash}`);
})().catch(err => {
    console.error(err);
    process.exit(1);
});

